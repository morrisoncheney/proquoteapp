<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Guitar Hero — Standalone</title>
<style>
  :root{
    --bg:#0b0f1a;
    --lane:#0f1724;
    --line:#24303f;
    --accent:#3ec7b6;
    --hit:#ffd166;
    --miss:#ff6b6b;
    color: #e6eef6;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center}
  .wrap{width:980px;max-width:96vw;padding:18px;box-sizing:border-box}
  h1{margin:0 0 10px;font-size:20px}
  .top{display:flex;gap:12px;align-items:center;margin-bottom:12px}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:#1b2836;border:1px solid #273242;color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}
  button:active{transform:translateY(1px)}
  label{font-size:13px;color:#9fb0c8}
  .hud{margin-left:auto;text-align:right;font-size:13px}
  canvas{display:block;width:100%;border-radius:8px;background:linear-gradient(180deg,#07101a 0%, #08151f 100%);box-shadow:0 6px 18px rgba(0,0,0,0.6)}
  .legend{display:flex;gap:8px;align-items:center;margin-top:8px;font-size:13px}
  .key{display:inline-block;padding:6px 8px;border-radius:6px;background:#0f2230;border:1px solid #21333f}
  .footer{margin-top:10px;color:#9fb0c8;font-size:13px}
  .stat{font-weight:700;color:var(--accent);font-size:16px}
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <h1>Mini Guitar Hero — Press <span class="key">A S D F G</span></h1>
      <div style="font-size:13px;color:#9fb0c8">Hit the notes as they cross the hit line. Click Play to start.</div>
    </div>

    <div class="controls">
      <button id="playBtn">Play</button>
      <button id="pauseBtn">Pause</button>
      <label>
        Speed
        <input id="speed" type="range" min="0.6" max="1.8" step="0.05" value="1" />
      </label>
      <label>
        Difficulty
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </label>
      <div class="hud">
        <div>Score: <span id="score" class="stat">0</span></div>
        <div>Combo: <span id="combo" class="stat">0</span></div>
        <div>Hit %: <span id="acc" class="stat">0%</span></div>
      </div>
    </div>
  </div>

  <canvas id="game" width="960" height="540"></canvas>

  <div class="legend">
    <div><strong>Keys</strong></div>
    <div><span class="key">A</span> lane 1</div>
    <div><span class="key">S</span> lane 2</div>
    <div><span class="key">D</span> lane 3</div>
    <div><span class="key">F</span> lane 4</div>
    <div><span class="key">G</span> lane 5</div>
  </div>

  <div class="footer">
    Single-file demo — synthesized hit sounds only. Works with keyboard or clicking/tapping lanes.
  </div>
</div>

<script>
/*
  Mini Guitar Hero (single-file)
  - 5 lanes
  - Keyboard: A S D F G
  - Click/Tap lanes also supported
  - Synthesized hit sounds via WebAudio Oscillators
  - Notes spawn using a simple pattern; speed & difficulty adjustable
*/

(() => {
  // Canvas setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  // UI elements
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const speedControl = document.getElementById('speed');
  const difficultySel = document.getElementById('difficulty');
  const scoreEl = document.getElementById('score');
  const comboEl = document.getElementById('combo');
  const accEl = document.getElementById('acc');

  // Resize canvas resolution for crispness
  function resize() {
    const ratio = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    canvas.width = Math.floor(w * ratio);
    canvas.height = Math.floor(h * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Game parameters
  const LANES = 5;
  const keys = ['a','s','d','f','g'];
  let laneX = []; // pixel x centers
  let laneW;
  const hitLineY = canvas.height / (window.devicePixelRatio||1) - 110;
  let running = false;
  let lastFrame = 0;
  let startTime = 0;
  let elapsed = 0;
  let gameTime = 0;
  let notes = [];
  let nextNoteIdx = 0;
  let spawnInterval = 400; // ms baseline, variable by difficulty and speed
  let songLength = 60_000; // 1 minute demo
  let score = 0, combo = 0, hits = 0, attempts = 0;
  const hitWindow = { perfect: 80, good: 160, ok: 240 }; // ms windows
  let audioCtx = null;

  // Difficulty presets
  function getDifficulty() {
    const d = difficultySel.value;
    if (d === 'easy') return { density:0.6, speedMult:0.9 };
    if (d === 'normal') return { density:1.0, speedMult:1.0 };
    return { density:1.4, speedMult:1.18 };
  }

  // Build pattern: for demo we construct a timed sequence (ms offsets)
  function buildPattern() {
    notes = [];
    const diff = getDifficulty();
    const baseBeat = 400; // ms between beats at tempo baseline
    const density = diff.density;
    const totalBeats = Math.floor(songLength / baseBeat);
    let time = 1500; // initial lead-in 1.5s
    for (let b=0;b<totalBeats;b++) {
      // Decide whether to spawn on this beat
      if (Math.random() < 0.85 * density) {
        // maybe a chord or single note
        const chordChance = Math.random();
        if (chordChance < 0.12) {
          // 2-3 note chord
          const count = 2 + Math.floor(Math.random()*2);
          const lanes = shuffle([...Array(LANES).keys()]).slice(0,count);
          for (const l of lanes) notes.push({ t: time, lane: l, hit:false, judged:false });
        } else {
          // single note (prefer middle lanes a bit)
          let laneBias = Math.random();
          let lane;
          if (laneBias < 0.12) lane = 0;
          else if (laneBias < 0.28) lane = 4;
          else lane = 1 + Math.floor(Math.random()*3);
          notes.push({ t: time, lane, hit:false, judged:false });
        }
      }
      // occasional quick double
      if (Math.random() < 0.08 * density) {
        notes.push({ t: time + baseBeat/2, lane: Math.floor(Math.random()*LANES), hit:false, judged:false });
      }
      time += baseBeat * (0.9 + Math.random()*0.6); // small tempo variance
    }
    notes.sort((a,b)=>a.t-b.t);
    nextNoteIdx = 0;
  }

  // Utility
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a }

  // Initialize lane geometry
  function computeLanes() {
    const pad = 28;
    const w = canvas.clientWidth - pad*2;
    laneW = Math.floor(w / LANES);
    laneX = [];
    for (let i=0;i<LANES;i++){
      laneX.push(pad + i*laneW + laneW/2);
    }
  }
  computeLanes();
  window.addEventListener('resize', computeLanes);

  // Game control
  function startGame() {
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    score = 0; combo = 0; hits=0; attempts=0;
    scoreEl.textContent = score; comboEl.textContent = combo; accEl.textContent = '0%';
    buildPattern();
    running = true;
    startTime = performance.now();
    lastFrame = startTime;
    gameTime = 0;
    animate(startTime);
  }

  function pauseGame() {
    running = false;
  }

  playBtn.addEventListener('click', ()=> {
    startGame();
  });
  pauseBtn.addEventListener('click', ()=> {
    pauseGame();
  });

  // Sound on hit
  function playHitSound(lane, quality) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const freqs = [220, 262, 330, 392, 523]; // per-lane base
    o.type = 'sine';
    o.frequency.value = freqs[lane] * (quality === 'perfect' ? 1.25 : quality==='good'?1.05:0.95);
    g.gain.value = (quality === 'perfect' ? 0.09 : quality==='good'?0.07:0.05);
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + 0.12 + (quality==='perfect'?0.05:0));
  }
  function playMissSound(){
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sawtooth'; o.frequency.value = 110;
    g.gain.value = 0.06;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.12);
  }

  // Hit detection when player presses a lane (timestamp is performance.now())
  function handleHit(lane, now) {
    // find nearest unjudged note in lane within allowed window
    let bestIdx = -1;
    let bestDiff = Infinity;
    for (let i=0;i<notes.length;i++){
      const n = notes[i];
      if (n.lane !== lane || n.judged) continue;
      const diff = Math.abs((gameTime) - n.t); // ms diff
      if (diff < bestDiff && diff <= hitWindow.ok) { bestDiff = diff; bestIdx = i; }
    }
    attempts++;
    if (bestIdx >= 0) {
      const n = notes[bestIdx];
      n.judged = true; n.hit = true;
      // score based on timing
      let quality='ok';
      let s = 50;
      if (bestDiff <= hitWindow.perfect) { quality='perfect'; s=300; }
      else if (bestDiff <= hitWindow.good) { quality='good'; s=150; }
      else { quality='ok'; s=70; }
      combo++; score += Math.round(s * (1 + combo*0.002));
      hits++;
      playHitSound(lane, quality);
      showHitEffect(lane, quality);
    } else {
      // miss (no note)
      combo = 0;
      score = Math.max(0, score - 40);
      playMissSound();
      showMissEffect(lane);
    }
    updateHUD();
  }

  // HUD update
  function updateHUD(){
    scoreEl.textContent = score;
    comboEl.textContent = combo;
    accEl.textContent = attempts ? Math.round(100 * hits / attempts) + '%' : '0%';
  }

  // Visual effects queue
  const effects = [];
  function showHitEffect(lane, quality){
    effects.push({ lane, t: gameTime, type:'hit', quality });
  }
  function showMissEffect(lane){
    effects.push({ lane, t: gameTime, type:'miss' });
  }

  // Key handling
  const activeKeys = new Set();
  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    const li = keys.indexOf(k);
    if (li >= 0 && !activeKeys.has(k)) {
      activeKeys.add(k);
      handleHit(li, performance.now());
    }
  });
  window.addEventListener('keyup', (e)=>{
    const k = e.key.toLowerCase();
    if (activeKeys.has(k)) activeKeys.delete(k);
  });

  // Mouse/touch lane clicking
  canvas.addEventListener('pointerdown', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left);
    // determine lane by x
    for (let i=0;i<LANES;i++){
      const left = laneX[i] - laneW/2;
      const right = laneX[i] + laneW/2;
      if (x >= left && x <= right) {
        handleHit(i, performance.now());
        return;
      }
    }
  });

  // Animation / drawing
  function animate(now) {
    if (!running) return;
    const dt = now - lastFrame;
    lastFrame = now;
    elapsed = now - startTime;
    // gameTime is logical ms into song, affected by speed control
    const speed = Number(speedControl.value) * getDifficulty().speedMult;
    gameTime += dt * speed;

    // spawn notes based on scheduled times — in this implementation spawn just means they exist in notes[] already; we just draw based on gameTime
    // judge early notes that have passed hit window without being hit -> miss
    for (let i=0;i<notes.length;i++){
      const n = notes[i];
      if (!n.judged && (gameTime - n.t) > hitWindow.ok) {
        n.judged = true;
        n.hit = false;
        combo = 0;
        attempts++;
        playMissSound();
        showMissEffect(n.lane);
        updateHUD();
      }
    }

    // clear
    ctx.fillStyle = '#07101a';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // draw lanes
    const pad = 28;
    for (let i=0;i<LANES;i++){
      const x = laneX[i] - laneW/2;
      // lane background
      ctx.fillStyle = '#0f1724';
      ctx.fillRect(x, 24, laneW-6, canvas.clientHeight - 150);
      // vertical separators
      ctx.fillStyle = '#0c2533';
      ctx.fillRect(x + laneW - 8, 24, 6, canvas.clientHeight - 150);
      // key label at bottom
      ctx.fillStyle = '#e6eef6';
      ctx.font = '14px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(keys[i].toUpperCase(), laneX[i], canvas.clientHeight - 78);
      // neon bar at bottom (hit target)
      ctx.fillStyle = '#162632';
      ctx.fillRect(x+4, hitLineY-8, laneW-14, 18);
    }

    // draw notes
    const travel = 1400 / speed; // ms it takes a note to travel from spawn to hitline (roughly), adjust by speed
    for (let i=0;i<notes.length;i++){
      const n = notes[i];
      // map n.t relative to gameTime to y position: if n.t is gameTime => on hitline
      const dtms = n.t - gameTime; // ms until hit
      const frac = 1 - (dtms / travel); // 0 at spawn point to 1 at hitline
      const radius = Math.max(8, 18 - (dtms/1000)*2);
      const x = laneX[n.lane];
      const spawnY = 40;
      const destY = hitLineY;
      const y = spawnY + frac * (destY - spawnY);

      // only draw if in visible range
      if (y > spawnY - 40 && y < canvas.clientHeight + 40) {
        // color
        ctx.beginPath();
        ctx.fillStyle = n.hit ? 'rgba(60,220,180,0.6)' : '#3ec7b6';
        // slightly dim notes that are past hitline (dtms < 0)
        if (dtms < -200) ctx.fillStyle = 'rgba(120,120,120,0.45)';
        ctx.arc(x, y, 12 + Math.max(0, (frac*6)), 0, Math.PI*2);
        ctx.fill();

        // outline
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#072b35';
        ctx.stroke();
      }
    }

    // draw hit line highlight
    ctx.fillStyle = 'rgba(62,199,182,0.06)';
    ctx.fillRect(20, hitLineY-28, canvas.clientWidth-40, 56);
    ctx.strokeStyle = '#1f3a42';
    ctx.lineWidth = 2;
    ctx.strokeRect(20, hitLineY-28, canvas.clientWidth-40, 56);

    // draw effects
    const nowGame = gameTime;
    for (let i=effects.length-1;i>=0;i--){
      const e = effects[i];
      const age = nowGame - e.t;
      if (age > 800) { effects.splice(i,1); continue; }
      const alpha = 1 - age/800;
      const x = laneX[e.lane];
      ctx.globalAlpha = alpha;
      if (e.type === 'hit') {
        ctx.fillStyle = e.quality === 'perfect' ? '#ffd166' : (e.quality==='good' ? '#9fe7d0' : '#cfeee7');
        ctx.beginPath();
        const size = 20 + (1 - age/400) * 20;
        ctx.arc(x, hitLineY - 10, size, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(x-22, hitLineY-28 - age*0.05, 44, 14);
      }
      ctx.globalAlpha = 1;
    }

    // HUD overlay small
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(14, 10, 220, 60);
    ctx.fillStyle = '#9fb0c8';
    ctx.font = '13px system-ui, sans-serif';
    ctx.fillText('Score: ' + score, 26, 30);
    ctx.fillText('Combo: ' + combo, 26, 50);
    ctx.fillText('Accuracy: ' + (attempts? Math.round(100*hits/attempts) + '%' : '0%'), 120, 30);
    ctx.fillText('Time: ' + Math.max(0, Math.floor(gameTime/1000)) + 's', 120, 50);

    // End condition
    if (gameTime > songLength + 3000) {
      running = false;
      // show end message
      setTimeout(()=> {
        alert('Song ended! Score: ' + score + '\\nAccuracy: ' + (attempts? Math.round(100*hits/attempts) + '%':'0%') + '\\nCombo: ' + combo);
      }, 80);
      return;
    }

    requestAnimationFrame(animate);
  }

  // Periodically update spawnInterval based on speed/difficulty
  setInterval(()=>{
    const diff = getDifficulty();
    spawnInterval = 380 / diff.speedMult;
  },250);

  // Judge notes that are close to hitline visually (optional - already judged on hit or pass)
  // (Left intentionally minimal.)

  // Simple helper to start audio on first user gesture for compatibility
  window.addEventListener('click', ()=> {
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  }, { once:true });

  // initial layout
  computeLanes();
  updateHUD();

})();
</script>
</body>
</html>
